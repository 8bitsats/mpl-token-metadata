/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import { Program, ProgramError } from '@lorisleiva/js-core';

type ProgramErrorConstructor = new (
  program: Program,
  cause?: Error
) => ProgramError;
const codeToErrorMap: Map<number, ProgramErrorConstructor> = new Map();
const nameToErrorMap: Map<string, ProgramErrorConstructor> = new Map();

/** NumericalOverflow: 'Numerical Overflow' */
export class TaNumericalOverflowError extends ProgramError {
  readonly name: string = 'NumericalOverflow';

  readonly code: number = 0x0; // 0

  constructor(program: Program, cause?: Error) {
    super('Numerical Overflow', program, cause);
  }
}
codeToErrorMap.set(0x0, TaNumericalOverflowError);
nameToErrorMap.set('NumericalOverflow', TaNumericalOverflowError);

/** DataTypeMismatch: 'Data type mismatch' */
export class TaDataTypeMismatchError extends ProgramError {
  readonly name: string = 'DataTypeMismatch';

  readonly code: number = 0x1; // 1

  constructor(program: Program, cause?: Error) {
    super('Data type mismatch', program, cause);
  }
}
codeToErrorMap.set(0x1, TaDataTypeMismatchError);
nameToErrorMap.set('DataTypeMismatch', TaDataTypeMismatchError);

/** DataSliceUnexpectedIndexError: 'Data slice unexpected index error' */
export class TaDataSliceUnexpectedIndexErrorError extends ProgramError {
  readonly name: string = 'DataSliceUnexpectedIndexError';

  readonly code: number = 0x2; // 2

  constructor(program: Program, cause?: Error) {
    super('Data slice unexpected index error', program, cause);
  }
}
codeToErrorMap.set(0x2, TaDataSliceUnexpectedIndexErrorError);
nameToErrorMap.set(
  'DataSliceUnexpectedIndexError',
  TaDataSliceUnexpectedIndexErrorError
);

/** IncorrectOwner: 'Incorrect account owner' */
export class TaIncorrectOwnerError extends ProgramError {
  readonly name: string = 'IncorrectOwner';

  readonly code: number = 0x3; // 3

  constructor(program: Program, cause?: Error) {
    super('Incorrect account owner', program, cause);
  }
}
codeToErrorMap.set(0x3, TaIncorrectOwnerError);
nameToErrorMap.set('IncorrectOwner', TaIncorrectOwnerError);

/** PayloadVecIndexError: 'Could not index into PayloadVec' */
export class TaPayloadVecIndexErrorError extends ProgramError {
  readonly name: string = 'PayloadVecIndexError';

  readonly code: number = 0x4; // 4

  constructor(program: Program, cause?: Error) {
    super('Could not index into PayloadVec', program, cause);
  }
}
codeToErrorMap.set(0x4, TaPayloadVecIndexErrorError);
nameToErrorMap.set('PayloadVecIndexError', TaPayloadVecIndexErrorError);

/** DerivedKeyInvalid: 'Derived key invalid' */
export class TaDerivedKeyInvalidError extends ProgramError {
  readonly name: string = 'DerivedKeyInvalid';

  readonly code: number = 0x5; // 5

  constructor(program: Program, cause?: Error) {
    super('Derived key invalid', program, cause);
  }
}
codeToErrorMap.set(0x5, TaDerivedKeyInvalidError);
nameToErrorMap.set('DerivedKeyInvalid', TaDerivedKeyInvalidError);

/** PayerIsNotSigner: 'Payer is not a signer' */
export class TaPayerIsNotSignerError extends ProgramError {
  readonly name: string = 'PayerIsNotSigner';

  readonly code: number = 0x6; // 6

  constructor(program: Program, cause?: Error) {
    super('Payer is not a signer', program, cause);
  }
}
codeToErrorMap.set(0x6, TaPayerIsNotSignerError);
nameToErrorMap.set('PayerIsNotSigner', TaPayerIsNotSignerError);

/** NotImplemented: 'Not implemented' */
export class TaNotImplementedError extends ProgramError {
  readonly name: string = 'NotImplemented';

  readonly code: number = 0x7; // 7

  constructor(program: Program, cause?: Error) {
    super('Not implemented', program, cause);
  }
}
codeToErrorMap.set(0x7, TaNotImplementedError);
nameToErrorMap.set('NotImplemented', TaNotImplementedError);

/** BorshSerializationError: 'Borsh serialization error' */
export class TaBorshSerializationErrorError extends ProgramError {
  readonly name: string = 'BorshSerializationError';

  readonly code: number = 0x8; // 8

  constructor(program: Program, cause?: Error) {
    super('Borsh serialization error', program, cause);
  }
}
codeToErrorMap.set(0x8, TaBorshSerializationErrorError);
nameToErrorMap.set('BorshSerializationError', TaBorshSerializationErrorError);

/** BorshDeserializationError: 'Borsh deserialization error' */
export class TaBorshDeserializationErrorError extends ProgramError {
  readonly name: string = 'BorshDeserializationError';

  readonly code: number = 0x9; // 9

  constructor(program: Program, cause?: Error) {
    super('Borsh deserialization error', program, cause);
  }
}
codeToErrorMap.set(0x9, TaBorshDeserializationErrorError);
nameToErrorMap.set(
  'BorshDeserializationError',
  TaBorshDeserializationErrorError
);

/** ValueOccupied: 'Value in Payload or RuleSet is occupied' */
export class TaValueOccupiedError extends ProgramError {
  readonly name: string = 'ValueOccupied';

  readonly code: number = 0xa; // 10

  constructor(program: Program, cause?: Error) {
    super('Value in Payload or RuleSet is occupied', program, cause);
  }
}
codeToErrorMap.set(0xa, TaValueOccupiedError);
nameToErrorMap.set('ValueOccupied', TaValueOccupiedError);

/** DataIsEmpty: 'Account data is empty' */
export class TaDataIsEmptyError extends ProgramError {
  readonly name: string = 'DataIsEmpty';

  readonly code: number = 0xb; // 11

  constructor(program: Program, cause?: Error) {
    super('Account data is empty', program, cause);
  }
}
codeToErrorMap.set(0xb, TaDataIsEmptyError);
nameToErrorMap.set('DataIsEmpty', TaDataIsEmptyError);

/** MessagePackSerializationError: 'MessagePack serialization error' */
export class TaMessagePackSerializationErrorError extends ProgramError {
  readonly name: string = 'MessagePackSerializationError';

  readonly code: number = 0xc; // 12

  constructor(program: Program, cause?: Error) {
    super('MessagePack serialization error', program, cause);
  }
}
codeToErrorMap.set(0xc, TaMessagePackSerializationErrorError);
nameToErrorMap.set(
  'MessagePackSerializationError',
  TaMessagePackSerializationErrorError
);

/** MessagePackDeserializationError: 'MessagePack deserialization error' */
export class TaMessagePackDeserializationErrorError extends ProgramError {
  readonly name: string = 'MessagePackDeserializationError';

  readonly code: number = 0xd; // 13

  constructor(program: Program, cause?: Error) {
    super('MessagePack deserialization error', program, cause);
  }
}
codeToErrorMap.set(0xd, TaMessagePackDeserializationErrorError);
nameToErrorMap.set(
  'MessagePackDeserializationError',
  TaMessagePackDeserializationErrorError
);

/** MissingAccount: 'Missing account' */
export class TaMissingAccountError extends ProgramError {
  readonly name: string = 'MissingAccount';

  readonly code: number = 0xe; // 14

  constructor(program: Program, cause?: Error) {
    super('Missing account', program, cause);
  }
}
codeToErrorMap.set(0xe, TaMissingAccountError);
nameToErrorMap.set('MissingAccount', TaMissingAccountError);

/** MissingPayloadValue: 'Missing Payload value' */
export class TaMissingPayloadValueError extends ProgramError {
  readonly name: string = 'MissingPayloadValue';

  readonly code: number = 0xf; // 15

  constructor(program: Program, cause?: Error) {
    super('Missing Payload value', program, cause);
  }
}
codeToErrorMap.set(0xf, TaMissingPayloadValueError);
nameToErrorMap.set('MissingPayloadValue', TaMissingPayloadValueError);

/** RuleSetOwnerMismatch: 'RuleSet owner must be payer' */
export class TaRuleSetOwnerMismatchError extends ProgramError {
  readonly name: string = 'RuleSetOwnerMismatch';

  readonly code: number = 0x10; // 16

  constructor(program: Program, cause?: Error) {
    super('RuleSet owner must be payer', program, cause);
  }
}
codeToErrorMap.set(0x10, TaRuleSetOwnerMismatchError);
nameToErrorMap.set('RuleSetOwnerMismatch', TaRuleSetOwnerMismatchError);

/** NameTooLong: 'Name too long' */
export class TaNameTooLongError extends ProgramError {
  readonly name: string = 'NameTooLong';

  readonly code: number = 0x11; // 17

  constructor(program: Program, cause?: Error) {
    super('Name too long', program, cause);
  }
}
codeToErrorMap.set(0x11, TaNameTooLongError);
nameToErrorMap.set('NameTooLong', TaNameTooLongError);

/** OperationNotFound: 'The operation retrieved is not in the selected RuleSet' */
export class TaOperationNotFoundError extends ProgramError {
  readonly name: string = 'OperationNotFound';

  readonly code: number = 0x12; // 18

  constructor(program: Program, cause?: Error) {
    super(
      'The operation retrieved is not in the selected RuleSet',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x12, TaOperationNotFoundError);
nameToErrorMap.set('OperationNotFound', TaOperationNotFoundError);

/** RuleAuthorityIsNotSigner: 'Rule authority is not signer' */
export class TaRuleAuthorityIsNotSignerError extends ProgramError {
  readonly name: string = 'RuleAuthorityIsNotSigner';

  readonly code: number = 0x13; // 19

  constructor(program: Program, cause?: Error) {
    super('Rule authority is not signer', program, cause);
  }
}
codeToErrorMap.set(0x13, TaRuleAuthorityIsNotSignerError);
nameToErrorMap.set('RuleAuthorityIsNotSigner', TaRuleAuthorityIsNotSignerError);

/** UnsupportedRuleSetRevMapVersion: 'Unsupported RuleSet revision map version' */
export class TaUnsupportedRuleSetRevMapVersionError extends ProgramError {
  readonly name: string = 'UnsupportedRuleSetRevMapVersion';

  readonly code: number = 0x14; // 20

  constructor(program: Program, cause?: Error) {
    super('Unsupported RuleSet revision map version', program, cause);
  }
}
codeToErrorMap.set(0x14, TaUnsupportedRuleSetRevMapVersionError);
nameToErrorMap.set(
  'UnsupportedRuleSetRevMapVersion',
  TaUnsupportedRuleSetRevMapVersionError
);

/** UnsupportedRuleSetVersion: 'Unsupported RuleSet version' */
export class TaUnsupportedRuleSetVersionError extends ProgramError {
  readonly name: string = 'UnsupportedRuleSetVersion';

  readonly code: number = 0x15; // 21

  constructor(program: Program, cause?: Error) {
    super('Unsupported RuleSet version', program, cause);
  }
}
codeToErrorMap.set(0x15, TaUnsupportedRuleSetVersionError);
nameToErrorMap.set(
  'UnsupportedRuleSetVersion',
  TaUnsupportedRuleSetVersionError
);

/** UnexpectedRuleSetFailure: 'Unexpected RuleSet failure' */
export class TaUnexpectedRuleSetFailureError extends ProgramError {
  readonly name: string = 'UnexpectedRuleSetFailure';

  readonly code: number = 0x16; // 22

  constructor(program: Program, cause?: Error) {
    super('Unexpected RuleSet failure', program, cause);
  }
}
codeToErrorMap.set(0x16, TaUnexpectedRuleSetFailureError);
nameToErrorMap.set('UnexpectedRuleSetFailure', TaUnexpectedRuleSetFailureError);

/** RuleSetRevisionNotAvailable: 'RuleSet revision not available' */
export class TaRuleSetRevisionNotAvailableError extends ProgramError {
  readonly name: string = 'RuleSetRevisionNotAvailable';

  readonly code: number = 0x17; // 23

  constructor(program: Program, cause?: Error) {
    super('RuleSet revision not available', program, cause);
  }
}
codeToErrorMap.set(0x17, TaRuleSetRevisionNotAvailableError);
nameToErrorMap.set(
  'RuleSetRevisionNotAvailable',
  TaRuleSetRevisionNotAvailableError
);

/** AdditionalSignerCheckFailed: 'Additional Signer check failed' */
export class TaAdditionalSignerCheckFailedError extends ProgramError {
  readonly name: string = 'AdditionalSignerCheckFailed';

  readonly code: number = 0x18; // 24

  constructor(program: Program, cause?: Error) {
    super('Additional Signer check failed', program, cause);
  }
}
codeToErrorMap.set(0x18, TaAdditionalSignerCheckFailedError);
nameToErrorMap.set(
  'AdditionalSignerCheckFailed',
  TaAdditionalSignerCheckFailedError
);

/** PubkeyMatchCheckFailed: 'Pubkey Match check failed' */
export class TaPubkeyMatchCheckFailedError extends ProgramError {
  readonly name: string = 'PubkeyMatchCheckFailed';

  readonly code: number = 0x19; // 25

  constructor(program: Program, cause?: Error) {
    super('Pubkey Match check failed', program, cause);
  }
}
codeToErrorMap.set(0x19, TaPubkeyMatchCheckFailedError);
nameToErrorMap.set('PubkeyMatchCheckFailed', TaPubkeyMatchCheckFailedError);

/** PubkeyListMatchCheckFailed: 'Pubkey List Match check failed' */
export class TaPubkeyListMatchCheckFailedError extends ProgramError {
  readonly name: string = 'PubkeyListMatchCheckFailed';

  readonly code: number = 0x1a; // 26

  constructor(program: Program, cause?: Error) {
    super('Pubkey List Match check failed', program, cause);
  }
}
codeToErrorMap.set(0x1a, TaPubkeyListMatchCheckFailedError);
nameToErrorMap.set(
  'PubkeyListMatchCheckFailed',
  TaPubkeyListMatchCheckFailedError
);

/** PubkeyTreeMatchCheckFailed: 'Pubkey Tree Match check failed' */
export class TaPubkeyTreeMatchCheckFailedError extends ProgramError {
  readonly name: string = 'PubkeyTreeMatchCheckFailed';

  readonly code: number = 0x1b; // 27

  constructor(program: Program, cause?: Error) {
    super('Pubkey Tree Match check failed', program, cause);
  }
}
codeToErrorMap.set(0x1b, TaPubkeyTreeMatchCheckFailedError);
nameToErrorMap.set(
  'PubkeyTreeMatchCheckFailed',
  TaPubkeyTreeMatchCheckFailedError
);

/** PDAMatchCheckFailed: 'PDA Match check failed' */
export class TaPDAMatchCheckFailedError extends ProgramError {
  readonly name: string = 'PDAMatchCheckFailed';

  readonly code: number = 0x1c; // 28

  constructor(program: Program, cause?: Error) {
    super('PDA Match check failed', program, cause);
  }
}
codeToErrorMap.set(0x1c, TaPDAMatchCheckFailedError);
nameToErrorMap.set('PDAMatchCheckFailed', TaPDAMatchCheckFailedError);

/** ProgramOwnedCheckFailed: 'Program Owned check failed' */
export class TaProgramOwnedCheckFailedError extends ProgramError {
  readonly name: string = 'ProgramOwnedCheckFailed';

  readonly code: number = 0x1d; // 29

  constructor(program: Program, cause?: Error) {
    super('Program Owned check failed', program, cause);
  }
}
codeToErrorMap.set(0x1d, TaProgramOwnedCheckFailedError);
nameToErrorMap.set('ProgramOwnedCheckFailed', TaProgramOwnedCheckFailedError);

/** ProgramOwnedListCheckFailed: 'Program Owned List check failed' */
export class TaProgramOwnedListCheckFailedError extends ProgramError {
  readonly name: string = 'ProgramOwnedListCheckFailed';

  readonly code: number = 0x1e; // 30

  constructor(program: Program, cause?: Error) {
    super('Program Owned List check failed', program, cause);
  }
}
codeToErrorMap.set(0x1e, TaProgramOwnedListCheckFailedError);
nameToErrorMap.set(
  'ProgramOwnedListCheckFailed',
  TaProgramOwnedListCheckFailedError
);

/** ProgramOwnedTreeCheckFailed: 'Program Owned Tree check failed' */
export class TaProgramOwnedTreeCheckFailedError extends ProgramError {
  readonly name: string = 'ProgramOwnedTreeCheckFailed';

  readonly code: number = 0x1f; // 31

  constructor(program: Program, cause?: Error) {
    super('Program Owned Tree check failed', program, cause);
  }
}
codeToErrorMap.set(0x1f, TaProgramOwnedTreeCheckFailedError);
nameToErrorMap.set(
  'ProgramOwnedTreeCheckFailed',
  TaProgramOwnedTreeCheckFailedError
);

/** AmountCheckFailed: 'Amount checked failed' */
export class TaAmountCheckFailedError extends ProgramError {
  readonly name: string = 'AmountCheckFailed';

  readonly code: number = 0x20; // 32

  constructor(program: Program, cause?: Error) {
    super('Amount checked failed', program, cause);
  }
}
codeToErrorMap.set(0x20, TaAmountCheckFailedError);
nameToErrorMap.set('AmountCheckFailed', TaAmountCheckFailedError);

/** FrequencyCheckFailed: 'Frequency check failed' */
export class TaFrequencyCheckFailedError extends ProgramError {
  readonly name: string = 'FrequencyCheckFailed';

  readonly code: number = 0x21; // 33

  constructor(program: Program, cause?: Error) {
    super('Frequency check failed', program, cause);
  }
}
codeToErrorMap.set(0x21, TaFrequencyCheckFailedError);
nameToErrorMap.set('FrequencyCheckFailed', TaFrequencyCheckFailedError);

/** IsWalletCheckFailed: 'IsWallet check failed' */
export class TaIsWalletCheckFailedError extends ProgramError {
  readonly name: string = 'IsWalletCheckFailed';

  readonly code: number = 0x22; // 34

  constructor(program: Program, cause?: Error) {
    super('IsWallet check failed', program, cause);
  }
}
codeToErrorMap.set(0x22, TaIsWalletCheckFailedError);
nameToErrorMap.set('IsWalletCheckFailed', TaIsWalletCheckFailedError);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
export function getMplTokenAuthRulesErrorFromCode(
  code: number,
  program: Program,
  cause?: Error
): ProgramError | null {
  const constructor = codeToErrorMap.get(code);
  return constructor ? new constructor(program, cause) : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
export function getMplTokenAuthRulesErrorFromName(
  name: string,
  program: Program,
  cause?: Error
): ProgramError | null {
  const constructor = nameToErrorMap.get(name);
  return constructor ? new constructor(program, cause) : null;
}
